// Generated by CoffeeScript 1.3.3
(function() {
  var createCanvas, namespace, __FNT__createLoadingScene, __end_loading, __frenetic_init,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  namespace = function(target, name, block) {
    var item, top, _i, _len, _ref, _ref1;
    if (arguments.length < 3) {
      _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
    }
    top = target;
    _ref1 = name.split('.');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      target = target[item] || (target[item] = {});
    }
    return block(target, top);
  };

  namespace("FNT", function(exports) {
    return exports.ObservableModel = (function() {

      function ObservableModel() {
        this.observers = [];
        this;

      }

      ObservableModel.prototype.addObserver = function(observer) {
        this.observers.push(observer);
        return this;
      };

      /*  
       # Notify observers of a model event.
       #   The Event is an object with fields:
       #     eventType | eventData
       # @param eventType : a string indicating the event type
       # @param eventData an object with event data. Each event type will have its own data structure.
       # @param eventSource the object firing the event
      */


      ObservableModel.prototype.notifyObservers = function(eventType, eventData, eventSource) {
        var observer, _i, _len, _ref, _results;
        if (eventSource == null) {
          eventSource = this;
        }
        _ref = this.observers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          observer = _ref[_i];
          _results.push(observer.handleEvent({
            type: eventType,
            data: eventData,
            source: eventSource
          }));
        }
        return _results;
      };

      return ObservableModel;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.GameModes = {
      quest: {
        name: "quest",
        levelData: [
          {
            spawnLocation: {
              x: 312,
              y: 200
            },
            exit: {
              x: 400,
              y: 100
            },
            ringData: [
              {
                x: 500,
                y: 500,
                diameter: 900
              }, {
                x: 100,
                y: 300,
                diameter: 190
              }, {
                x: 300,
                y: 600,
                diameter: 200
              }, {
                x: 512,
                y: 512,
                diameter: 100
              }, {
                x: 750,
                y: 800,
                diameter: 320
              }, {
                x: 820,
                y: 680,
                diameter: 120
              }, {
                x: 600,
                y: 300,
                diameter: 250
              }, {
                x: 800,
                y: 300,
                diameter: 250
              }
            ]
          }, {
            spawnLocation: {
              x: 512,
              y: 800
            },
            exit: {
              x: 300,
              y: 300
            },
            ringData: [
              {
                x: 500,
                y: 500,
                diameter: 1000
              }, {
                x: 500,
                y: 500,
                diameter: 300
              }, {
                x: 100,
                y: 100,
                diameter: 100
              }
            ]
          }, {
            spawnLocation: {
              x: 80,
              y: 200
            },
            exit: {
              x: 200,
              y: 100
            },
            ringData: [
              {
                x: 100,
                y: 800,
                diameter: 150
              }, {
                x: 550,
                y: 750,
                diameter: 150
              }, {
                x: 900,
                y: 600,
                diameter: 150
              }, {
                x: 600,
                y: 300,
                diameter: 150
              }
            ]
          }, {
            spawnLocation: {
              x: 512,
              y: 800
            },
            exit: {
              x: 300,
              y: 300
            },
            ringData: [
              {
                x: 500,
                y: 500,
                diameter: 1000
              }
            ]
          }
        ]
      },
      race: {
        name: 'race'
      },
      pwn: {
        name: 'pwn'
      }
    };
  });

  namespace("FNT", function(exports) {
    exports.PlayerEvents = {
      STATE_CHANGE: "player_event_state_change",
      SPAWN: "player_event_spawn",
      NEW_POSITION: "player_event_new_position"
    };
    exports.PlayerStates = {
      NORMAL: "player_state_normal",
      ORBITING: "player_state_orbiting",
      DEAD: "player_state_dead"
    };
    exports.PlayerFactory = (function() {

      function PlayerFactory() {}

      PlayerFactory.build = function() {
        var player, stateMachine;
        player = new FNT.PlayerModel().create();
        stateMachine = new FNT.StateMachine(player);
        player.state = stateMachine;
        return player;
      };

      return PlayerFactory;

    })();
    return exports.PlayerModel = (function(_super) {

      __extends(PlayerModel, _super);

      function PlayerModel() {
        PlayerModel.__super__.constructor.call(this);
        this;

      }

      PlayerModel.prototype.radius = 12;

      PlayerModel.prototype.COLOR = "#F00";

      PlayerModel.prototype.ORBITING_COLOR = "orange";

      PlayerModel.prototype.create = function() {
        this.position = new CAAT.Point(0, 0);
        this.diameter = this.radius * 2;
        return this;
      };

      PlayerModel.prototype.setPosition = function(pos) {
        this.position.set(pos.x, pos.y);
        return this.notifyObservers(FNT.PlayerEvents.NEW_POSITION, this);
      };

      /* Spawn in the given LevelModel at the given spawnLocation
      */


      PlayerModel.prototype.spawn = function(spawnLocation) {
        this.position.x = spawnLocation.x;
        this.position.y = spawnLocation.y;
        return this.notifyObservers(FNT.PlayerEvents.SPAWN, this);
      };

      return PlayerModel;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    exports.RingEvents = {
      ORBITED: "ring_event_orbited"
    };
    return exports.RingModel = (function(_super) {

      __extends(RingModel, _super);

      function RingModel() {
        this.position = new CAAT.Point(0, 0);
        RingModel.__super__.constructor.call(this);
        this;

      }

      RingModel.prototype.diameter = 0;

      RingModel.prototype.create = function(ringData) {
        this.position = new CAAT.Point(ringData.x, ringData.y);
        this.diameter = ringData.diameter;
        this.radius = this.diameter / 2;
        return this;
      };

      RingModel.prototype.setOrbited = function(orbited) {
        this.orbited = orbited;
        return this.notifyObservers(FNT.RingEvents.ORBITED, this.orbited);
      };

      return RingModel;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    exports.LevelFactory = (function() {

      function LevelFactory() {}

      LevelFactory.build = function(levelData) {
        var level;
        level = new FNT.LevelModel();
        level.load(levelData);
        return level;
      };

      return LevelFactory;

    })();
    return exports.LevelModel = (function(_super) {

      __extends(LevelModel, _super);

      function LevelModel() {
        LevelModel.__super__.constructor.call(this);
        this;

      }

      LevelModel.prototype.load = function(levelData) {
        var ring, _i, _len, _ref, _results;
        this.spawnLocation = levelData.spawnLocation;
        this.exit = levelData.exit;
        this.rings = [];
        _ref = levelData.ringData;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ring = _ref[_i];
          _results.push(this.rings.push(new FNT.RingModel().create(ring)));
        }
        return _results;
      };

      LevelModel.prototype.getRings = function() {
        return this.rings;
      };

      LevelModel.prototype.resetAllRings = function() {
        var ring, _i, _len, _ref, _results;
        _ref = this.rings;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ring = _ref[_i];
          _results.push(ring.setOrbited(false));
        }
        return _results;
      };

      return LevelModel;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    exports.LevelSequenceEvents = {
      NEXT_LEVEL: "level_sequence_event_next_level"
    };
    exports.LevelSequenceStates = {
      PREPARING: "level_state_preparing",
      READY: "level_state_ready",
      PLAYING: "level_state_playing"
    };
    exports.LevelSequenceFactory = (function() {

      function LevelSequenceFactory() {}

      LevelSequenceFactory.build = function(allLevels) {
        var levelData, levelSequence, stateMachine, _i, _len;
        levelSequence = new FNT.LevelSequence();
        stateMachine = new FNT.StateMachine(levelSequence);
        levelSequence.state = stateMachine;
        for (_i = 0, _len = allLevels.length; _i < _len; _i++) {
          levelData = allLevels[_i];
          levelSequence.addLevel(FNT.LevelFactory.build(levelData));
        }
        return levelSequence;
      };

      return LevelSequenceFactory;

    })();
    return exports.LevelSequence = (function(_super) {

      __extends(LevelSequence, _super);

      function LevelSequence(_levels) {
        this._levels = _levels != null ? _levels : [];
        this._currentIndex = 0;
        LevelSequence.__super__.constructor.call(this);
        this;

      }

      LevelSequence.prototype.addLevel = function(levelModel) {
        return this._levels.push(levelModel);
      };

      LevelSequence.prototype.start = function() {
        this._currentIndex = 0;
        return this.state.set(FNT.LevelSequenceStates.PREPARING);
      };

      LevelSequence.prototype.currentLevel = function() {
        return this._levels[this._currentIndex];
      };

      LevelSequence.prototype.nextLevel = function() {
        return this._levels[this._currentIndex + 1];
      };

      LevelSequence.prototype.advance = function() {
        if (this._currentIndex < (this._levels.length - 2)) {
          this._currentIndex += 1;
        }
        return this.state.set(FNT.LevelSequenceStates.PREPARING);
      };

      return LevelSequence;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    return exports.GameModel = (function(_super) {

      __extends(GameModel, _super);

      function GameModel(levelSequence, player) {
        this.levelSequence = levelSequence;
        this.player = player;
        this.levelSequence.addObserver(this);
        GameModel.__super__.constructor.call(this);
        this;

      }

      GameModel.prototype.step = function() {
        if (this.physicsController != null) {
          return this.physicsController.step();
        }
      };

      GameModel.prototype.handleEvent = function(event) {
        switch (event.data) {
          case FNT.LevelSequenceStates.READY:
            return this.startLevel();
        }
      };

      GameModel.prototype.startGame = function() {
        return this.levelSequence.start();
      };

      GameModel.prototype.startLevel = function() {
        this.player.spawn(this.levelSequence.currentLevel().spawnLocation);
        return this.levelSequence.state.set(FNT.LevelSequenceStates.PLAYING);
      };

      GameModel.prototype.nextLevel = function() {
        return this.levelSequence.advance();
      };

      return GameModel;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    return exports.StateMachine = (function(_super) {

      __extends(StateMachine, _super);

      function StateMachine(entity) {
        this.entity = entity;
        StateMachine.__super__.constructor.call(this);
        this.state = null;
        this;

      }

      StateMachine.prototype.get = function() {
        return this.state;
      };

      StateMachine.prototype.set = function(newState) {
        var oldState;
        if (newState === this.state) {
          return;
        }
        oldState = newState;
        this.state = newState;
        return this.entity.notifyObservers(this.state, oldState);
      };

      return StateMachine;

    })(FNT.ObservableModel);
  });

  /*
   # Base class for circle-shaped Actors
  */


  namespace("FNT", function(exports) {
    return exports.CircleActor = (function(_super) {

      __extends(CircleActor, _super);

      function CircleActor() {
        CircleActor.__super__.constructor.call(this);
        this;

      }

      CircleActor.prototype.setPosition = function(point) {
        return this.centerAt(point.x, point.y);
      };

      CircleActor.prototype.setDiameter = function(diameter) {
        return this.setSize(diameter, diameter);
      };

      return CircleActor;

    })(CAAT.ShapeActor);
  });

  /*
   # Player Actor
  */


  namespace("FNT", function(exports) {
    return exports.PlayerActor = (function(_super) {

      __extends(PlayerActor, _super);

      function PlayerActor() {
        PlayerActor.__super__.constructor.call(this);
        this;

      }

      PlayerActor.prototype.create = function(scene, playerModel) {
        this.playerModel = playerModel;
        this.setVisible(false);
        this.setDiameter(this.playerModel.diameter);
        this.setPosition(this.playerModel.position);
        this.setLineWidth(2);
        this.setStrokeStyle('#0');
        this.setFillStyle(this.playerModel.COLOR);
        this.prepareSpawnBehavior();
        this.playerModel.addObserver(this);
        scene.addChild(this);
        return this;
      };

      PlayerActor.prototype.prepareSpawnBehavior = function() {
        this.spawnScaleBehavior = new CAAT.ScaleBehavior().setPingPong().setValues(1, 1.3, 1, 1.3, .50, .50).setDelayTime(0, 1000);
        return this.spawnAlphaBehavior = new CAAT.AlphaBehavior().setValues(0, 1).setDelayTime(0, 1000);
      };

      PlayerActor.prototype.handleEvent = function(event) {
        switch (event.type) {
          case FNT.PlayerEvents.SPAWN:
            return this.spawn();
          case FNT.PlayerEvents.NEW_POSITION:
            return this.setPosition(this.playerModel.position);
          case FNT.PlayerStates.NORMAL:
            return this.setFillStyle(this.playerModel.COLOR);
          case FNT.PlayerStates.ORBITING:
            return this.setFillStyle(this.playerModel.ORBITING_COLOR);
        }
      };

      PlayerActor.prototype.spawn = function() {
        this.setPosition(this.playerModel.position);
        this.addBehavior(this.spawnScaleBehavior);
        this.addBehavior(this.spawnAlphaBehavior);
        return this.setVisible(true);
      };

      return PlayerActor;

    })(FNT.CircleActor);
  });

  namespace("FNT", function(exports) {
    return exports.RingActor = (function(_super) {

      __extends(RingActor, _super);

      function RingActor() {
        RingActor.__super__.constructor.call(this);
        this;

      }

      RingActor.prototype.create = function(ring, alpha) {
        this.ring = ring;
        if (alpha == null) {
          alpha = 0.5;
        }
        this.setDiameter(ring.diameter);
        this.setPosition(ring.position);
        this.setStrokeStyle('#0');
        this.setFillStyle('#AAA');
        this.setAlpha(alpha);
        this.ring.addObserver(this);
        return this;
      };

      RingActor.prototype.handleEvent = function(event) {
        switch (event.type) {
          case FNT.RingEvents.ORBITED:
            return this.orbit(event.data);
        }
      };

      RingActor.prototype.orbit = function(orbited) {
        if (orbited) {
          this.setLineWidth(2);
          return this.setFillStyle('yellow');
        } else {
          this.setLineWidth(1);
          return this.setFillStyle('#AAA');
        }
      };

      return RingActor;

    })(FNT.CircleActor);
  });

  namespace("FNT", function(exports) {
    return exports.PortalBorderActor = (function(_super) {

      __extends(PortalBorderActor, _super);

      function PortalBorderActor() {
        PortalBorderActor.__super__.constructor.call(this);
        this;

      }

      PortalBorderActor.prototype.create = function(diameter, position) {
        this.setDiameter(diameter);
        this.setPosition(position);
        this.setFillStyle('gold');
        this.setAlpha(1);
        return this;
      };

      return PortalBorderActor;

    })(FNT.CircleActor);
  });

  namespace("FNT", function(exports) {
    exports.NextLevelPortal = (function(_super) {

      __extends(NextLevelPortal, _super);

      NextLevelPortal.SCALE = 0.05;

      function NextLevelPortal() {
        NextLevelPortal.__super__.constructor.call(this);
        this.ringActors = [];
        this;

      }

      NextLevelPortal.prototype.prepare = function(levelModel, width, height) {
        var ringModel, _i, _len, _ref;
        this.levelModel = levelModel;
        this.setSize(width, height);
        this._createBorder(width);
        _ref = this.levelModel.getRings();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ringModel = _ref[_i];
          this._create(ringModel);
        }
        this.setScale(FNT.NextLevelPortal.SCALE, FNT.NextLevelPortal.SCALE);
        return this;
      };

      NextLevelPortal.prototype._createBorder = function(sceneWidth) {
        var diameter, position, r;
        r = sceneWidth / 2;
        position = {
          x: r,
          y: r
        };
        diameter = Math.sqrt(2 * sceneWidth * sceneWidth);
        this.borderActor = new FNT.PortalBorderActor().create(diameter, position);
        return this.addChild(this.borderActor);
      };

      NextLevelPortal.prototype._create = function(ringModel) {
        var ringActor;
        ringActor = new FNT.RingActor().create(ringModel, 0.8);
        this.ringActors.push(ringActor);
        return this.addChild(ringActor);
      };

      return NextLevelPortal;

    })(CAAT.ActorContainer);
    return exports.LevelActorContainer = (function(_super) {

      __extends(LevelActorContainer, _super);

      function LevelActorContainer() {
        LevelActorContainer.__super__.constructor.call(this);
        this.ringActors = [];
        this;

      }

      LevelActorContainer.prototype.create = function(scene, levelSequence) {
        this.scene = scene;
        this.levelSequence = levelSequence;
        this.levelSequence.addObserver(this);
        this.scene.addChild(this);
        return this;
      };

      LevelActorContainer.prototype.handleEvent = function(event) {
        switch (event.data) {
          case FNT.LevelSequenceStates.PREPARING:
            return this.drawLevel();
        }
      };

      LevelActorContainer.prototype.drawLevel = function() {
        var exitLocation, ringActor, ringModel, _i, _j, _len, _len1, _ref, _ref1;
        this._clearCurrentLevel();
        _ref = this.levelSequence.currentLevel().getRings();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ringModel = _ref[_i];
          this._create(ringModel);
        }
        _ref1 = this.ringActors;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          ringActor = _ref1[_j];
          this._animate(ringActor);
        }
        if (this.nextLevelPortal != null) {
          this.removeChild(this.nextLevelPortal);
          this.nextLevelPortal.setDiscardable(true).setExpired(true);
        }
        this.nextLevelPortal = new FNT.NextLevelPortal().prepare(this.levelSequence.nextLevel(), this.width, this.height);
        exitLocation = this.levelSequence.currentLevel().exit;
        this.nextLevelPortal.centerAt(exitLocation.x, exitLocation.y);
        this.addChild(this.nextLevelPortal);
        return this;
      };

      LevelActorContainer.prototype._clearCurrentLevel = function() {
        var ring, _i, _len, _ref;
        _ref = this.ringActors;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ring = _ref[_i];
          ring.setDiscardable(true).setExpired(true);
        }
        return this.ringActors = [];
      };

      LevelActorContainer.prototype._create = function(ringModel) {
        var ringActor;
        ringActor = new FNT.RingActor().create(ringModel);
        ringActor.setVisible(false);
        this.ringActors.push(ringActor);
        return this.addChild(ringActor);
      };

      LevelActorContainer.prototype._animate = function(ringActor) {
        this._animateInUsingScale(ringActor, this.scene.time, 1000);
        return ringActor.setVisible(true);
      };

      /*
           # Adds a CAAT.ScaleBehavior to the entity, used on animate in
      */


      LevelActorContainer.prototype._animateInUsingScale = function(actor, startTime, duration) {
        var _ref;
        if ((_ref = this.scaleBehavior) == null) {
          this.scaleBehavior = this._createScaleBehavior();
        }
        actor.scaleX = actor.scaleY = this.scaleBehavior.startScaleX;
        this.scaleBehavior.setFrameTime(startTime, duration);
        return actor.addBehavior(this.scaleBehavior);
      };

      LevelActorContainer.prototype._createScaleBehavior = function(startScale, endScale) {
        var _this = this;
        this.scaleBehavior = new CAAT.ScaleBehavior();
        this.scaleBehavior.anchor = CAAT.Actor.prototype.ANCHOR_CENTER;
        this.scaleBehavior.startScaleX = this.scaleBehavior.startScaleY = 0.1;
        this.scaleBehavior.endScaleX = this.scaleBehavior.endScaleY = 1;
        this.scaleBehavior.setCycle(false);
        this.scaleBehavior.setInterpolator(new CAAT.Interpolator().createBounceOutInterpolator(false));
        this.scaleBehavior.addListener({
          behaviorExpired: function(behavior, time, actor) {
            return _this._doneAnimating();
          }
        });
        return this.scaleBehavior;
      };

      LevelActorContainer.prototype._doneAnimating = function() {
        return this.levelSequence.state.set(FNT.LevelSequenceStates.READY);
      };

      return LevelActorContainer;

    })(CAAT.ActorContainer);
  });

  namespace("FNT", function(exports) {
    return exports.BackgroundContainer = (function(_super) {

      __extends(BackgroundContainer, _super);

      function BackgroundContainer() {
        BackgroundContainer.__super__.constructor.call(this);
        this;

      }

      BackgroundContainer.prototype.create = function(scene, width, height) {
        this.setBounds(0, 0, width, height);
        this.setFillStyle("#555");
        scene.addChild(this);
        return this;
      };

      return BackgroundContainer;

    })(CAAT.ActorContainer);
  });

  /*
   # Game Scene Actor:
   #  Main entry point for all the Actors that constitute the scene.
   #  Responsible for creating the scene with the Director.
  */


  namespace("FNT", function(exports) {
    exports.GameSceneActorFactory = (function() {

      function GameSceneActorFactory() {}

      GameSceneActorFactory.build = function(director, gameModel, gameController) {
        var gameActor;
        gameActor = new FNT.GameSceneActor().create(director, gameModel, gameController);
        return gameActor;
      };

      return GameSceneActorFactory;

    })();
    return exports.GameSceneActor = (function() {

      function GameSceneActor() {
        this;

      }

      /*
           # Creates the main game Scene.
           # @param director a CAAT.Director instance.
           # @param gameModel The FNT.GameModel instance that this Actor will represent.
      */


      GameSceneActor.prototype.create = function(director, gameModel, gameController) {
        var _this = this;
        this.director = director;
        this.gameModel = gameModel;
        this.gameController = gameController;
        this.directorScene = director.createScene();
        this.directorScene.activated = function() {
          return _this.gameModel.startGame();
        };
        this.directorScene.onRenderStart = function(deltaTime) {
          return _this.gameController.step();
        };
        this.backgroundContainer = new FNT.BackgroundContainer().create(this.directorScene, director.width, director.height);
        this.createLevelContainer(this.gameModel.levelSequence);
        this.createPlayer(this.gameModel.player);
        return this;
      };

      GameSceneActor.prototype.createLevelContainer = function(levelSequence) {
        return this.levelActorContainer = new FNT.LevelActorContainer().create(this.directorScene, levelSequence).setSize(this.director.width, this.director.height).setLocation(0, 0);
      };

      GameSceneActor.prototype.createPlayer = function(player) {
        return this.playerActor = new FNT.PlayerActor().create(this.directorScene, player);
      };

      return GameSceneActor;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.GameController = (function() {

      function GameController(gameModel, physicsController, keyboard) {
        this.gameModel = gameModel;
        this.physicsController = physicsController;
        this.keyboard = keyboard;
        this.registerKeyListeners(this.keyboard);
        this;

      }

      GameController.prototype.step = function() {
        if (this.physicsController != null) {
          return this.physicsController.step();
        }
      };

      GameController.prototype.reset = function() {
        return this.gameModel.startLevel();
      };

      GameController.prototype.registerKeyListeners = function() {
        var _this = this;
        this.keyboard.RESET.addListener(FNT.KeyDown, function() {
          return _this.reset();
        });
        return this.keyboard.NEXT_LEVEL.addListener(FNT.KeyDown, function() {
          return _this.gameModel.nextLevel();
        });
      };

      return GameController;

    })();
  });

  /* Encapsulates the state of Keyboard input
  */


  namespace("FNT", function(exports) {
    exports.KeyUp = "FNT_KEY_UP_EVENT";
    exports.KeyDown = "FNT_KEY_DOWN_EVENT";
    exports.Key = (function() {

      function Key() {
        this.state = FNT.KeyUp;
        this.keyDownListeners = [];
        this.keyUpListeners = [];
        this;

      }

      Key.prototype.addListener = function(keyEvent, callback) {
        switch (keyEvent) {
          case FNT.KeyUp:
            return this.keyUpListeners.push(callback);
          case FNT.KeyDown:
            return this.keyDownListeners.push(callback);
          default:
            return alert("WEIRD STUFF HAPPENING!");
        }
      };

      Key.prototype.notifyListeners = function() {
        var callback, listeners, _i, _len, _results;
        listeners = this.state === FNT.KeyDown ? this.keyDownListeners : this.keyUpListeners;
        _results = [];
        for (_i = 0, _len = listeners.length; _i < _len; _i++) {
          callback = listeners[_i];
          _results.push(callback());
        }
        return _results;
      };

      return Key;

    })();
    return exports.Keyboard = (function() {

      function Keyboard() {
        this._keyMap = {};
        this._keyMap[CAAT.Keys.j] = this.ORBIT;
        this._keyMap[CAAT.Keys.r] = this.RESET;
        this._keyMap[CAAT.Keys.n] = this.NEXT_LEVEL;
        this;

      }

      Keyboard.prototype.ORBIT = new FNT.Key();

      Keyboard.prototype.RESET = new FNT.Key();

      Keyboard.prototype.NEXT_LEVEL = new FNT.Key();

      Keyboard.prototype.UP = false;

      Keyboard.prototype.DOWN = false;

      Keyboard.prototype.LEFT = false;

      Keyboard.prototype.RIGHT = false;

      Keyboard.prototype.create = function() {
        /*
               # Register a CAAT key listener function
        */

        var _this = this;
        CAAT.registerKeyListener(function(keyEvent) {
          return _this.checkInput(keyEvent);
        });
        return this;
      };

      Keyboard.prototype.addListener = function(key, keyEvent, callback) {
        if (!(this.listeners[key] != null)) {
          this.listeners[key] = {};
          this.listeners[key][FNT.KeyUp] = [];
          this.listeners[key][FNT.KeyDown] = [];
        }
        return this.listeners[key][keyEvent].push(callback);
      };

      Keyboard.prototype.notifyListeners = function(key, keyEvent) {
        var callback, _i, _len, _ref, _results;
        _ref = this.listeners[key][keyEvent];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback());
        }
        return _results;
      };

      Keyboard.prototype.getKeyState = function(keyEvent) {
        keyEvent.preventDefault();
        if (keyEvent.getAction() === 'down') {
          return FNT.KeyDown;
        } else {
          return FNT.KeyUp;
        }
      };

      Keyboard.prototype._handleKeyEvent = function(keyEvent) {
        var key, newState;
        key = this._keyMap[keyEvent.getKeyCode()];
        newState = this.getKeyState(keyEvent);
        if (newState !== key.state) {
          key.state = newState;
          return key.notifyListeners();
        }
      };

      Keyboard.prototype.checkInput = function(keyEvent) {
        switch (keyEvent.getKeyCode()) {
          case CAAT.Keys.UP:
          case CAAT.Keys.w:
            this.UP = this.getKeyState(keyEvent) === FNT.KeyDown;
            break;
          case CAAT.Keys.DOWN:
          case CAAT.Keys.s:
            this.DOWN = this.getKeyState(keyEvent) === FNT.KeyDown;
            break;
          case CAAT.Keys.LEFT:
          case CAAT.Keys.a:
            this.LEFT = this.getKeyState(keyEvent) === FNT.KeyDown;
            break;
          case CAAT.Keys.RIGHT:
          case CAAT.Keys.d:
            this.RIGHT = this.getKeyState(keyEvent) === FNT.KeyDown;
        }
        if (keyEvent.getKeyCode() in this._keyMap) {
          return this._handleKeyEvent(keyEvent);
        }
      };

      return Keyboard;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.PhysicsConstants = {
      GRAVITY: new Vector(0, 200.0),
      MOVE_SPEED: 200,
      JUMP_SPEED: -200,
      AIR_MOVE_SPEED: 60,
      ORBIT_SPEED: 200,
      ORBIT_ATTACH_THRESHOLD: 5,
      INITIAL_ORBIT_OFFSET: 12,
      MINIMUM_INNER_ORBIT_OFFSET: 6,
      MINIMUM_OUTER_ORBIT_OFFSET: 6,
      ORBIT_CHANGE_PER_SECOND: 6
    };
  });

  /* CouplePosition Behaviour couples the position of an arbitrary entity to a particle
  */


  namespace("FNT", function(exports) {
    return exports.CouplePosition = (function(_super) {

      __extends(CouplePosition, _super);

      function CouplePosition(target) {
        this.target = target;
        CouplePosition.__super__.constructor.apply(this, arguments);
      }

      CouplePosition.prototype.apply = function(p, dt, index) {
        return this.target.setPosition(p.pos);
      };

      return CouplePosition;

    })(Behaviour);
  });

  /* This Behaviour handles Collisions with the FNT.LevelModel
  */


  namespace("FNT", function(exports) {
    return exports.LevelCollision = (function(_super) {

      __extends(LevelCollision, _super);

      function LevelCollision(levelSequence, keyboard, useMass, callback) {
        this.levelSequence = levelSequence;
        this.keyboard = keyboard;
        this.useMass = useMass != null ? useMass : true;
        this.callback = callback != null ? callback : null;
        this._delta = new Vector();
        LevelCollision.__super__.constructor.apply(this, arguments);
      }

      LevelCollision.prototype.setActive = function(isActive) {
        this.isActive = isActive;
      };

      LevelCollision.prototype.apply = function(p, dt, index) {
        if (!this.isActive) {
          return;
        }
        this.handleCollisions(p);
        return this.applyUserInput(p);
      };

      LevelCollision.prototype.handleCollisions = function(p) {
        var delta, dist, inner_perimeter, outer_perimeter, outward_force, overlap, ring, _i, _len, _ref, _results;
        this.onRing = false;
        _ref = this.levelSequence.currentLevel().getRings();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ring = _ref[_i];
          this._delta.copy(p.pos).sub(ring.position);
          dist = this._delta.mag();
          outer_perimeter = ring.radius + p.radius;
          inner_perimeter = ring.radius - p.radius;
          if ((inner_perimeter < dist && dist < outer_perimeter)) {
            if (dist > ring.radius) {
              if (p.pos.y < ring.position.y) {
                this.onRing = true;
              }
              overlap = outer_perimeter - dist;
              delta = this._delta.clone();
              outward_force = delta.dot(p.vel) / delta.magSq();
              if (outward_force >= 0) {
                p.pos.add(p.vel.clone().norm().scale(overlap / 10));
              } else {
                p.pos.add(this._delta.norm().scale(overlap));
              }
            } else {
              if (p.pos.y > ring.position.y) {
                this.onRing = true;
              }
              overlap = inner_perimeter - dist;
              p.pos.add(this._delta.norm().scale(overlap));
            }
            _results.push(typeof this.callback === "function" ? this.callback(p, o, overlap) : void 0);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      LevelCollision.prototype.applyUserInput = function(p) {
        var speed;
        speed = FNT.PhysicsConstants.AIR_MOVE_SPEED;
        if (this.onRing) {
          speed = FNT.PhysicsConstants.MOVE_SPEED;
          if (this.keyboard.JUMP) {
            p.acc.add(new Vector(0, FNT.PhysicsConstants.JUMP_SPEED));
          }
        }
        if (this.keyboard.LEFT) {
          p.acc.add(new Vector(-1 * speed, 0));
        }
        if (this.keyboard.RIGHT) {
          return p.acc.add(new Vector(speed, 0));
        }
      };

      return LevelCollision;

    })(Behaviour);
  });

  /* This behaviour attaches the particle to the first Ring it encounters and 'glides' it around the Ring
  */


  namespace("FNT", function(exports) {
    return exports.Orbiter = (function(_super) {

      __extends(Orbiter, _super);

      function Orbiter(levelSequence, keyboard, callback) {
        this.levelSequence = levelSequence;
        this.keyboard = keyboard;
        this.callback = callback != null ? callback : null;
        this._delta = new Vector();
        this._acceleration = new Vector();
        this._accumulated_acceleration = new Vector();
        this.orbit = 0;
        this.TRACKING_FACTOR = 1.0;
        Orbiter.__super__.constructor.apply(this, arguments);
        this;

      }

      Orbiter.prototype.setActive = function(isActive) {
        this.isActive = isActive;
        return this.ring = null;
      };

      Orbiter.prototype.applyUserInput = function(p, dt) {
        var speed;
        this._acceleration.clear();
        speed = FNT.PhysicsConstants.ORBIT_SPEED;
        if (this.keyboard.UP) {
          this._acceleration.y -= speed;
        }
        if (this.keyboard.DOWN) {
          this._acceleration.y += speed;
        }
        if (this.keyboard.RIGHT) {
          this._acceleration.x += speed;
        }
        if (this.keyboard.LEFT) {
          this._acceleration.x -= speed;
        }
        this._accumulated_acceleration.add(this._acceleration);
        this.adjustOrbitOverTime(p, dt);
        return p.acc.add(this._acceleration);
      };

      Orbiter.prototype.adjustOrbitOverTime = function(p, dt) {
        if (this.orbit > this.ring.radius) {
          if (this.orbit > (this.ring.radius + FNT.PhysicsConstants.MINIMUM_OUTER_ORBIT_OFFSET)) {
            return this.orbit -= dt * FNT.PhysicsConstants.ORBIT_CHANGE_PER_SECOND;
          }
        } else {
          if (this.orbit < (this.ring.radius - FNT.PhysicsConstants.MINIMUM_INNER_ORBIT_OFFSET)) {
            return this.orbit += dt * FNT.PhysicsConstants.ORBIT_CHANGE_PER_SECOND;
          }
        }
      };

      Orbiter.prototype.applyTracking = function(p) {
        var dist, force;
        dist = this.distanceBetween(p, this.ring) + 0.000001;
        force = (this.orbit - dist) * this.TRACKING_FACTOR;
        return p.pos.add(this._delta.norm().scale(force));
      };

      Orbiter.prototype.apply = function(p, dt, index) {
        var _ref;
        if (!this.isActive) {
          return;
        }
        if ((_ref = this.ring) == null) {
          this.ring = this.findAttachableRing(p);
        }
        if (!(this.ring != null)) {
          return;
        }
        this.applyTracking(p);
        return this.applyUserInput(p, dt);
      };

      Orbiter.prototype.findAttachableRing = function(p) {
        var dist, inner_perimeter, outer_perimeter, r, threshold, _i, _len, _ref;
        _ref = this.levelSequence.currentLevel().getRings();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          r = _ref[_i];
          dist = this.distanceBetween(p, r);
          outer_perimeter = r.radius + p.radius;
          inner_perimeter = r.radius - p.radius;
          threshold = FNT.PhysicsConstants.ORBIT_ATTACH_THRESHOLD;
          if ((inner_perimeter - threshold < dist && dist < outer_perimeter + threshold)) {
            this.ring = r;
            this._accumulated_acceleration.clear();
            if (dist < this.ring.radius) {
              this.orbit = this.ring.radius - FNT.PhysicsConstants.INITIAL_ORBIT_OFFSET;
            } else {
              this.orbit = this.ring.radius + FNT.PhysicsConstants.INITIAL_ORBIT_OFFSET;
            }
            if (typeof this.callback === "function") {
              this.callback(p, this.ring);
            }
            return this.ring;
          }
        }
        return null;
      };

      Orbiter.prototype.distanceBetween = function(a, b) {
        this._delta.copy(a.pos).sub(b.position);
        return this._delta.mag();
      };

      return Orbiter;

    })(Behaviour);
  });

  /* This behaviour calls a callback when particles enter a specific circle
  */


  namespace("FNT", function(exports) {
    return exports.Portal = (function(_super) {

      __extends(Portal, _super);

      function Portal(levelSequence, player, radius, callback) {
        this.levelSequence = levelSequence;
        this.player = player;
        this.radius = radius;
        this.callback = callback;
        Portal.__super__.constructor.call(this);
        this._delta = new Vector();
        this;

      }

      Portal.prototype.apply = function(p, dt, index) {
        var dist, position;
        if (this.player.state.get() === FNT.PlayerStates.DEAD) {
          return;
        }
        position = this._getPortalPosition();
        dist = this._delta.copy(position).sub(p.pos).mag();
        if (dist < this.radius) {
          return this.callback();
        }
      };

      Portal.prototype._getPortalPosition = function() {
        return new Vector(this.levelSequence.currentLevel().exit.x, this.levelSequence.currentLevel().exit.y);
      };

      return Portal;

    })(Behaviour);
  });

  /* This class models a Player's interaction with the physics system
  */


  namespace("FNT", function(exports) {
    return exports.PlayerParticle = (function(_super) {

      __extends(PlayerParticle, _super);

      function PlayerParticle() {
        PlayerParticle.__super__.constructor.call(this);
        this;

      }

      PlayerParticle.prototype.create = function(playerModel, levelSequence, keyboard) {
        var _this = this;
        this.playerModel = playerModel;
        this.levelSequence = levelSequence;
        this.keyboard = keyboard;
        this.couplePosition = new FNT.CouplePosition(this.playerModel);
        this.keyboard.ORBIT.addListener(FNT.KeyDown, function() {
          return _this.setOrbitState(true);
        });
        this.keyboard.ORBIT.addListener(FNT.KeyUp, function() {
          return _this.setOrbitState(false);
        });
        this.setRadius(this.playerModel.radius);
        this.levelCollision = new FNT.LevelCollision(this.levelSequence, this.keyboard);
        this.orbiter = new FNT.Orbiter(this.levelSequence, this.keyboard, this.onOrbitStart);
        this.levelCollision.setActive(false);
        this.orbiter.setActive(false);
        this.behaviours.push(this.orbiter);
        this.behaviours.push(this.levelCollision);
        this.behaviours.push(this.couplePosition);
        this.playerModel.addObserver(this);
        return this;
      };

      PlayerParticle.prototype.setOrbitState = function(isOrbiting) {
        this.clearState();
        this.orbiter.setActive(isOrbiting);
        return this.levelCollision.setActive(!isOrbiting);
      };

      PlayerParticle.prototype.clearState = function() {
        this.playerModel.state.set(FNT.PlayerStates.NORMAL);
        return this.levelSequence.currentLevel().resetAllRings();
      };

      PlayerParticle.prototype.handleEvent = function(event) {
        switch (event.type) {
          case FNT.PlayerEvents.SPAWN:
            return this.spawn();
          case FNT.PlayerStates.DEAD:
            return this.fixed = true;
        }
      };

      PlayerParticle.prototype.onOrbitStart = function(p, ring) {
        p.playerModel.state.set(FNT.PlayerStates.ORBITING);
        return ring.setOrbited(true);
      };

      PlayerParticle.prototype.spawn = function() {
        this.fixed = false;
        this.moveTo(new Vector(this.playerModel.position.x, this.playerModel.position.y));
        this.orbiter.setActive(false);
        return this.levelCollision.setActive(true);
      };

      return PlayerParticle;

    })(Particle);
  });

  /* Controller responsible for physics
  */


  namespace("FNT", function(exports) {
    return exports.PhysicsController = (function() {

      function PhysicsController() {}

      PhysicsController.prototype.create = function(gameModel, keyboard) {
        var _this = this;
        this.gameModel = gameModel;
        this.keyboard = keyboard;
        this.physics = new Physics(new Verlet());
        this.gravity = new ConstantForce(FNT.PhysicsConstants.GRAVITY);
        this.physics.behaviours.push(this.gravity);
        this.initPlayerPhysics(this.gameModel.player, this.gameModel.levelSequence);
        this.portal = new FNT.Portal(this.gameModel.levelSequence, this.gameModel.player, 50, function() {
          return _this.onPortalCollision();
        });
        this.physics.behaviours.push(this.portal);
        this.gameModel.addObserver(this);
        return this;
      };

      PhysicsController.prototype.step = function() {
        return this.physics.step();
      };

      PhysicsController.prototype.initPlayerPhysics = function(playerModel, levelSequence) {
        this.player = new FNT.PlayerParticle().create(playerModel, levelSequence, this.keyboard);
        return this.physics.particles.push(this.player);
      };

      PhysicsController.prototype.onPortalCollision = function() {
        this.gameModel.player.state.set(FNT.PlayerStates.DEAD);
        return this.gameModel.nextLevel();
      };

      return PhysicsController;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.GameFactory = (function(_super) {

      __extends(GameFactory, _super);

      function GameFactory() {
        return GameFactory.__super__.constructor.apply(this, arguments);
      }

      GameFactory.build = function(director) {
        var gameController, gameModel;
        gameModel = this.createGameModel();
        gameController = this.createGameController(gameModel);
        return this.createGameView(director, gameModel, gameController);
      };

      GameFactory.createGameModel = function() {
        var levelSequence, playerModel;
        levelSequence = FNT.LevelSequenceFactory.build(FNT.GameModes.quest.levelData);
        playerModel = FNT.PlayerFactory.build();
        return new FNT.GameModel(levelSequence, playerModel);
      };

      GameFactory.createGameController = function(gameModel) {
        var keyboard, physics;
        keyboard = new FNT.Keyboard().create();
        physics = new FNT.PhysicsController().create(gameModel, keyboard);
        return new FNT.GameController(gameModel, physics, keyboard);
      };

      GameFactory.createGameView = function(director, gameModel, gameController) {
        var gameScene;
        return gameScene = FNT.GameSceneActorFactory.build(director, gameModel, gameController);
      };

      return GameFactory;

    })(FNT.ObservableModel);
  });

  /*
   # Main Entry Point
  */


  __FNT__createLoadingScene = function(director) {
    var ladingActor, ladingImg, oActor, oImg, scene;
    ladingImg = director.getImage('lading');
    oImg = director.getImage('rueda');
    scene = director.createScene();
    scene.addChild(new CAAT.Actor().setBackgroundImage(director.getImage('splash')));
    scene.addChild(ladingActor = new CAAT.Actor().setBackgroundImage(ladingImg).setLocation(director.width - ladingImg.width - 10, director.height - ladingImg.height - 30));
    scene.addChild(oActor = new CAAT.Actor().setBackgroundImage(oImg).setLocation(ladingActor.x + 20, ladingActor.y + 10).addBehavior(new CAAT.RotateBehavior().setValues(0, 2 * Math.PI).setFrameTime(0, 1000).setCycle(true)));
    scene.loadedImage = function(count, images) {
      if (count === images.length) {
        return __end_loading(director, images);
      }
    };
    return scene;
  };

  __end_loading = function(director, images) {
    var gameScene;
    director.emptyScenes();
    director.setImagesCache(images);
    gameScene = FNT.GameFactory.build(director);
    return director.easeIn(0, CAAT.Scene.prototype.EASE_TRANSLATE, 1000, false, CAAT.Actor.prototype.ANCHOR_TOP, new CAAT.Interpolator().createExponentialInOutInterpolator(5, false));
  };

  createCanvas = function() {
    return new CAAT.Director().initialize(1000, 1000).setClear(false);
  };

  __frenetic_init = function() {
    var director, prefix;
    CAAT.DEBUG = 1;
    director = createCanvas();
    prefix = typeof __RESOURCE_URL !== "undefined" && __RESOURCE_URL !== null ? __RESOURCE_URL : '';
    new CAAT.ImagePreloader().loadImages([
      {
        id: 'splash',
        url: prefix + 'splash/splash.jpg'
      }, {
        id: 'lading',
        url: prefix + 'splash/lading.png'
      }, {
        id: 'rueda',
        url: prefix + 'splash/rueda.png'
      }
    ], function(counter, images) {
      var loading_scene;
      if (counter === images.length) {
        director.setImagesCache(images);
        loading_scene = __FNT__createLoadingScene(director);
        return new CAAT.ImagePreloader().loadImages([], function(counter, images) {
          if (counter === images.length) {
            director.addAudio("music", prefix + "res/sound/music.mp3");
          }
          return loading_scene.loadedImage(counter, images);
        });
      }
    });
    return CAAT.loop(60);
  };

  window.addEventListener('load', __frenetic_init, false);

}).call(this);
