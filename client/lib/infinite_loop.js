// Generated by CoffeeScript 1.3.3
(function() {
  var namespace,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  namespace = function(target, name, block) {
    var item, top, _i, _len, _ref, _ref1;
    if (arguments.length < 3) {
      _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
    }
    top = target;
    _ref1 = name.split('.');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      target = target[item] || (target[item] = {});
    }
    return block(target, top);
  };

  namespace("FNT", function(exports) {
    return exports.Time = (function() {

      function Time() {}

      Time.ONE_SECOND = 1000;

      Time.TWO_SECONDS = 2000;

      Time.THREE_SECONDS = 3000;

      Time.FOUR_SECONDS = 4000;

      return Time;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.Game = {
      WIDTH: 1000,
      HEIGHT: 1000,
      FONT: "sans-serif"
    };
  });

  namespace("FNT", function(exports) {
    return exports.Color = (function() {

      function Color() {}

      Color.scheme = "Paleta";

      Color._get = function(index) {
        return this[this.scheme][index];
      };

      Color.OddLots = {
        BUTTON: "#EDD4A8",
        BUTTON_DOWN: "#D4C472",
        BACKGROUND: "#5C565E",
        3: "#718F85",
        4: "#BA8A70"
      };

      Color.Lake = {
        BUTTON: "#D6DB86",
        BUTTON_DOWN: "#B7CC9F",
        BACKGROUND: "#90C2C4",
        3: "#D1DBCC",
        4: "#B8DEE3"
      };

      Color.Paleta = {
        3: "#006699",
        4: "#DB952E",
        BUTTON_DOWN: "#F2F03F",
        BUTTON: "#F93A34",
        BACKGROUND: "#E5E5E5"
      };

      Color.BUTTON = Color._get("BUTTON");

      Color.BUTTON_DOWN = Color._get("BUTTON_DOWN");

      Color.MEDIUM = Color._get(3);

      Color.MEDIUM_DULL = Color._get(4);

      Color.BACKGROUND = Color._get("BACKGROUND");

      Color.BLACK = "black";

      Color.FONT = "#444";

      return Color;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.Strings = (function() {

      function Strings() {}

      Strings.GAME_NAME = "Infinite Loop";

      Strings.NEW_GAME = "New Game";

      Strings.ABOUT = "About...";

      Strings.CLICK_TO_TOGGLE = "click to toggle";

      Strings.CONTROLS = "CONTROLS:";

      Strings.LEFT_AND_RIGHT = "'A' - left, 'D' - right";

      Strings.CLAMP = "'J' - clamp on to a nearby loop";

      Strings.RETRY = "'R' - retry the current level";

      return Strings;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.ObservableModel = (function() {

      function ObservableModel() {
        this.observers = [];
        this;

      }

      ObservableModel.prototype.addObserver = function(observer) {
        this.observers.push(observer);
        return this;
      };

      /*  
       # Notify observers of a model event.
       #   The Event is an object with fields:
       #     eventType | eventData
       # @param eventType : a string indicating the event type
       # @param eventData an object with event data. Each event type will have its own data structure.
       # @param eventSource the object firing the event
      */


      ObservableModel.prototype.notifyObservers = function(eventType, eventData, eventSource) {
        var observer, _i, _len, _ref, _results;
        if (eventSource == null) {
          eventSource = this;
        }
        _ref = this.observers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          observer = _ref[_i];
          _results.push(observer.handleEvent({
            type: eventType,
            data: eventData,
            source: eventSource
          }));
        }
        return _results;
      };

      return ObservableModel;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.GameModes = {
      quest: {
        name: "quest",
        levelData: [
          {
            spawnLocation: {
              x: 500,
              y: 500
            },
            exit: {
              x: 300,
              y: 800
            },
            ringData: [
              {
                x: 500,
                y: 500,
                diameter: 1000
              }
            ]
          }, {
            spawnLocation: {
              x: 512,
              y: 800
            },
            exit: {
              x: 300,
              y: 300
            },
            ringData: [
              {
                x: 500,
                y: 500,
                diameter: 1000
              }, {
                x: 500,
                y: 500,
                diameter: 300
              }, {
                x: 150,
                y: 150,
                diameter: 100
              }
            ]
          }, {
            spawnLocation: {
              x: 80,
              y: 200
            },
            exit: {
              x: 950,
              y: 800
            },
            ringData: [
              {
                x: 100,
                y: 800,
                diameter: 150
              }, {
                x: 600,
                y: 800,
                diameter: 150
              }
            ]
          }, {
            spawnLocation: {
              x: 312,
              y: 200
            },
            exit: {
              x: 950,
              y: 100
            },
            ringData: [
              {
                x: 500,
                y: 500,
                diameter: 900
              }, {
                x: 100,
                y: 300,
                diameter: 190
              }, {
                x: 300,
                y: 600,
                diameter: 200
              }, {
                x: 512,
                y: 512,
                diameter: 100
              }, {
                x: 750,
                y: 800,
                diameter: 320
              }, {
                x: 820,
                y: 680,
                diameter: 120
              }, {
                x: 600,
                y: 300,
                diameter: 250
              }, {
                x: 800,
                y: 300,
                diameter: 250
              }
            ]
          }
        ]
      },
      race: {
        name: 'race'
      },
      pwn: {
        name: 'pwn'
      }
    };
  });

  namespace("FNT", function(exports) {
    exports.PlayerConstants = {
      RADIUS: 10
    };
    exports.PlayerEvents = {
      STATE_CHANGE: "player_event_state_change",
      SPAWN: "player_event_spawn",
      NEW_POSITION: "player_event_new_position"
    };
    exports.PlayerStates = {
      NORMAL: "player_state_normal",
      ORBITING: "player_state_orbiting",
      DEAD: "player_state_dead"
    };
    exports.PlayerFactory = (function() {

      function PlayerFactory() {}

      PlayerFactory.build = function() {
        var player, stateMachine;
        player = new FNT.PlayerModel().create();
        stateMachine = new FNT.StateMachine(player);
        player.state = stateMachine;
        return player;
      };

      return PlayerFactory;

    })();
    return exports.PlayerModel = (function(_super) {

      __extends(PlayerModel, _super);

      function PlayerModel() {
        PlayerModel.__super__.constructor.call(this);
        this;

      }

      PlayerModel.prototype.COLOR = "#F00";

      PlayerModel.prototype.ORBITING_COLOR = "orange";

      PlayerModel.prototype.create = function() {
        this.position = new CAAT.Point(0, 0);
        this.diameter = FNT.PlayerConstants.RADIUS * 2;
        return this;
      };

      PlayerModel.prototype.setPosition = function(pos) {
        this.position.set(pos.x, pos.y);
        return this.notifyObservers(FNT.PlayerEvents.NEW_POSITION, this);
      };

      /* Spawn in the given LevelModel at the given spawnLocation
      */


      PlayerModel.prototype.spawn = function(spawnLocation) {
        this.position.x = spawnLocation.x;
        this.position.y = spawnLocation.y;
        this.notifyObservers(FNT.PlayerEvents.SPAWN, this);
        return this.state.set(FNT.PlayerStates.NORMAL);
      };

      return PlayerModel;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    exports.RingEvents = {
      ORBITED: "ring_event_orbited"
    };
    return exports.RingModel = (function(_super) {

      __extends(RingModel, _super);

      function RingModel() {
        this.position = new CAAT.Point(0, 0);
        RingModel.__super__.constructor.call(this);
        this;

      }

      RingModel.prototype.diameter = 0;

      RingModel.prototype.create = function(ringData) {
        this.position = new CAAT.Point(ringData.x, ringData.y);
        this.diameter = ringData.diameter;
        this.radius = this.diameter / 2;
        return this;
      };

      RingModel.prototype.setOrbited = function(orbited) {
        this.orbited = orbited;
        return this.notifyObservers(FNT.RingEvents.ORBITED, this.orbited);
      };

      return RingModel;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    exports.LevelFactory = (function() {

      function LevelFactory() {}

      LevelFactory.build = function(levelData) {
        var level;
        level = new FNT.LevelModel();
        level.load(levelData);
        return level;
      };

      return LevelFactory;

    })();
    return exports.LevelModel = (function(_super) {

      __extends(LevelModel, _super);

      function LevelModel() {
        LevelModel.__super__.constructor.call(this);
        this;

      }

      LevelModel.prototype.load = function(levelData) {
        var ring, _i, _len, _ref, _results;
        this.spawnLocation = levelData.spawnLocation;
        this.exit = levelData.exit;
        this.rings = [];
        _ref = levelData.ringData;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ring = _ref[_i];
          _results.push(this.rings.push(new FNT.RingModel().create(ring)));
        }
        return _results;
      };

      LevelModel.prototype.getRings = function() {
        return this.rings;
      };

      LevelModel.prototype.resetAllRings = function() {
        var ring, _i, _len, _ref, _results;
        _ref = this.rings;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ring = _ref[_i];
          _results.push(ring.setOrbited(false));
        }
        return _results;
      };

      return LevelModel;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    exports.LevelSequenceEvents = {
      NEXT_LEVEL: "level_sequence_event_next_level"
    };
    exports.LevelSequenceStates = {
      STARTING: "level_state_start",
      ADVANCING: "level_state_advancing",
      READY: "level_state_ready",
      PLAYING: "level_state_playing"
    };
    exports.LevelSequenceFactory = (function() {

      function LevelSequenceFactory() {}

      LevelSequenceFactory.build = function(allLevels) {
        var levelData, levelSequence, stateMachine, _i, _len;
        levelSequence = new FNT.LevelSequence();
        stateMachine = new FNT.StateMachine(levelSequence);
        levelSequence.state = stateMachine;
        for (_i = 0, _len = allLevels.length; _i < _len; _i++) {
          levelData = allLevels[_i];
          levelSequence.addLevel(FNT.LevelFactory.build(levelData));
        }
        return levelSequence;
      };

      return LevelSequenceFactory;

    })();
    return exports.LevelSequence = (function(_super) {

      __extends(LevelSequence, _super);

      function LevelSequence(_levels) {
        this._levels = _levels != null ? _levels : [];
        this._currentIndex = 0;
        LevelSequence.__super__.constructor.call(this);
        this;

      }

      LevelSequence.prototype.addLevel = function(levelModel) {
        return this._levels.push(levelModel);
      };

      LevelSequence.prototype.start = function() {
        this._currentIndex = 0;
        return this.state.set(FNT.LevelSequenceStates.STARTING);
      };

      LevelSequence.prototype.currentLevel = function() {
        return this._levels[this._currentIndex];
      };

      LevelSequence.prototype.nextLevel = function() {
        return this._levels[this._nextIndex()];
      };

      LevelSequence.prototype.advance = function() {
        this._currentIndex = this._nextIndex();
        return this.state.set(FNT.LevelSequenceStates.ADVANCING);
      };

      LevelSequence.prototype._nextIndex = function() {
        return (this._currentIndex + 1) % this._levels.length;
      };

      return LevelSequence;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    return exports.GameModel = (function(_super) {

      __extends(GameModel, _super);

      function GameModel(levelSequence, player) {
        this.levelSequence = levelSequence;
        this.player = player;
        this.levelSequence.addObserver(this);
        GameModel.__super__.constructor.call(this);
        this;

      }

      GameModel.prototype.step = function() {
        if (this.physicsController != null) {
          return this.physicsController.step();
        }
      };

      GameModel.prototype.handleEvent = function(event) {
        switch (event.data) {
          case FNT.LevelSequenceStates.READY:
            return this.startLevel();
        }
      };

      GameModel.prototype.startGame = function() {
        this.player.state.set(FNT.PlayerStates.DEAD);
        return this.levelSequence.start();
      };

      GameModel.prototype.startLevel = function() {
        this.player.spawn(this.levelSequence.currentLevel().spawnLocation);
        return this.levelSequence.state.set(FNT.LevelSequenceStates.PLAYING);
      };

      GameModel.prototype.nextLevel = function() {
        this.player.state.set(FNT.PlayerStates.DEAD);
        return this.levelSequence.advance();
      };

      return GameModel;

    })(FNT.ObservableModel);
  });

  namespace("FNT", function(exports) {
    return exports.StateMachine = (function(_super) {

      __extends(StateMachine, _super);

      function StateMachine(entity) {
        this.entity = entity;
        StateMachine.__super__.constructor.call(this);
        this.state = null;
        this;

      }

      StateMachine.prototype.get = function() {
        return this.state;
      };

      StateMachine.prototype.set = function(newState) {
        var oldState;
        if (newState === this.state) {
          return;
        }
        oldState = newState;
        this.state = newState;
        return this.entity.notifyObservers(this.state, oldState);
      };

      return StateMachine;

    })(FNT.ObservableModel);
  });

  /*
   # Base class for circle-shaped Actors
  */


  namespace("FNT", function(exports) {
    return exports.CircleActor = (function(_super) {

      __extends(CircleActor, _super);

      function CircleActor() {
        CircleActor.__super__.constructor.call(this);
        this;

      }

      CircleActor.prototype.setPosition = function(point) {
        this.centerAt(point.x, point.y);
        return this;
      };

      CircleActor.prototype.setDiameter = function(diameter) {
        this.setSize(diameter, diameter);
        return this;
      };

      return CircleActor;

    })(CAAT.ShapeActor);
  });

  /*
   # Player Actor
  */


  namespace("FNT", function(exports) {
    return exports.PlayerActor = (function(_super) {

      __extends(PlayerActor, _super);

      function PlayerActor() {
        PlayerActor.__super__.constructor.call(this);
        this;

      }

      PlayerActor.prototype.create = function(scene, playerModel) {
        this.playerModel = playerModel;
        this.setVisible(false);
        this.setDiameter(this.playerModel.diameter);
        this.setPosition(this.playerModel.position);
        this.setLineWidth(2);
        this.setStrokeStyle('#0');
        this.setFillStyle(this.playerModel.COLOR);
        this.prepareBehaviors();
        this.playerModel.addObserver(this);
        scene.addChild(this);
        return this;
      };

      PlayerActor.prototype.prepareBehaviors = function() {
        this.spawnScaleBehavior = new CAAT.ScaleBehavior().setPingPong().setValues(1, 1.3, 1, 1.3, .50, .50);
        this.spawnAlphaBehavior = new CAAT.AlphaBehavior().setValues(0, 1);
        return this.deathBehavior = new CAAT.ScaleBehavior().setValues(1, 0, 1, 0, .5, .5);
      };

      PlayerActor.prototype.handleEvent = function(event) {
        switch (event.type) {
          case FNT.PlayerEvents.SPAWN:
            return this.spawn();
          case FNT.PlayerEvents.NEW_POSITION:
            return this.setPosition(this.playerModel.position);
          case FNT.PlayerStates.NORMAL:
            return this.setFillStyle(this.playerModel.COLOR);
          case FNT.PlayerStates.ORBITING:
            return this.setFillStyle(this.playerModel.ORBITING_COLOR);
          case FNT.PlayerStates.DEAD:
            return this.kill();
        }
      };

      PlayerActor.prototype.spawn = function() {
        this.setPosition(this.playerModel.position);
        this.emptyBehaviorList();
        this.spawnScaleBehavior.setDelayTime(0, FNT.Time.ONE_SECOND);
        this.spawnAlphaBehavior.setDelayTime(0, FNT.Time.ONE_SECOND);
        this.addBehavior(this.spawnScaleBehavior);
        this.addBehavior(this.spawnAlphaBehavior);
        return this.setVisible(true);
      };

      PlayerActor.prototype.kill = function() {
        this.deathBehavior.setDelayTime(0, FNT.Time.ONE_SECOND);
        return this.addBehavior(this.deathBehavior);
      };

      return PlayerActor;

    })(FNT.CircleActor);
  });

  namespace("FNT", function(exports) {
    return exports.RingActor = (function(_super) {

      __extends(RingActor, _super);

      function RingActor() {
        RingActor.__super__.constructor.call(this);
        this;

      }

      RingActor.prototype.create = function(ring, alpha) {
        this.ring = ring;
        if (alpha == null) {
          alpha = 0.5;
        }
        this.setDiameter(ring.diameter);
        this.setPosition(ring.position);
        this.setStrokeStyle('#0');
        this.setFillStyle('#AAA');
        this.setAlpha(alpha);
        this.ring.addObserver(this);
        return this;
      };

      RingActor.prototype.handleEvent = function(event) {
        switch (event.type) {
          case FNT.RingEvents.ORBITED:
            return this.orbit(event.data);
        }
      };

      RingActor.prototype.orbit = function(orbited) {
        if (orbited) {
          this.setLineWidth(2);
          return this.setFillStyle('yellow');
        } else {
          this.setLineWidth(1);
          return this.setFillStyle('#AAA');
        }
      };

      return RingActor;

    })(FNT.CircleActor);
  });

  namespace("FNT", function(exports) {
    return exports.PortalBorderActor = (function(_super) {

      __extends(PortalBorderActor, _super);

      function PortalBorderActor() {
        PortalBorderActor.__super__.constructor.call(this);
        this;

      }

      PortalBorderActor.prototype.create = function(diameter, position) {
        this.setDiameter(diameter);
        this.setPosition(position);
        this.setFillStyle('gold');
        this.setAlpha(1);
        return this;
      };

      return PortalBorderActor;

    })(FNT.CircleActor);
  });

  namespace("FNT", function(exports) {
    return exports.LevelActor = (function(_super) {

      __extends(LevelActor, _super);

      LevelActor.PORTAL_SCALE = 0.05;

      function LevelActor() {
        LevelActor.__super__.constructor.call(this);
        this.setSize(FNT.Game.WIDTH, FNT.Game.HEIGHT);
        this.ringActors = [];
        this._prepareBehaviors();
        this;

      }

      LevelActor.prototype.prepare = function(levelModel, position) {
        var ringModel, _i, _len, _ref;
        this.levelModel = levelModel;
        this.emptyBehaviorList();
        this._createBorder();
        _ref = this.levelModel.getRings();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ringModel = _ref[_i];
          this._create(ringModel);
        }
        this.setScale(FNT.LevelActor.PORTAL_SCALE, FNT.LevelActor.PORTAL_SCALE);
        this.centerAt(position.x, position.y);
        return this;
      };

      LevelActor.prototype.discard = function() {
        var ring, _i, _len, _ref;
        _ref = this.ringActors;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ring = _ref[_i];
          ring.setDiscardable(true).setExpired(true);
        }
        this.borderActor.setDiscardable(true).setExpired(true);
        return this.setDiscardable(true).setExpired(true);
      };

      LevelActor.prototype._prepareBehaviors = function() {
        return this.fadeOut = new CAAT.AlphaBehavior().setValues(1, 0);
      };

      LevelActor.prototype._createBorder = function() {
        var diameter, position, r, sceneWidth;
        sceneWidth = FNT.Game.WIDTH;
        r = sceneWidth / 2;
        position = {
          x: r,
          y: r
        };
        diameter = Math.sqrt(2 * sceneWidth * sceneWidth);
        this.borderActor = new FNT.PortalBorderActor().create(diameter, position);
        return this.addChild(this.borderActor);
      };

      LevelActor.prototype.removeBorder = function() {
        return this.borderActor.addBehavior(this.fadeOut.setDelayTime(0, FNT.Time.ONE_SECOND));
      };

      LevelActor.prototype._create = function(ringModel) {
        var ringActor;
        ringActor = new FNT.RingActor().create(ringModel, 0.7);
        this.ringActors.push(ringActor);
        return this.addChild(ringActor);
      };

      return LevelActor;

    })(CAAT.ActorContainer);
  });

  namespace("FNT", function(exports) {
    return exports.LevelSequenceActor = (function(_super) {

      __extends(LevelSequenceActor, _super);

      function LevelSequenceActor() {
        LevelSequenceActor.__super__.constructor.call(this);
        this.setSize(FNT.Game.WIDTH, FNT.Game.HEIGHT);
        this.ringActors = [];
        this;

      }

      LevelSequenceActor.prototype.create = function(scene, levelSequence) {
        this.scene = scene;
        this.levelSequence = levelSequence;
        this.scene.addChild(this);
        this.levelSequence.addObserver(this);
        this._prepareZoom();
        return this;
      };

      LevelSequenceActor.prototype.handleEvent = function(event) {
        switch (event.data) {
          case FNT.LevelSequenceStates.STARTING:
            return this._startSequence();
          case FNT.LevelSequenceStates.ADVANCING:
            return this._advanceLevel();
        }
      };

      LevelSequenceActor.prototype._startSequence = function() {
        this._cleanAll();
        this._prepareNextLevel(this.levelSequence.currentLevel(), new CAAT.Point(FNT.Game.WIDTH / 2, FNT.Game.HEIGHT / 2));
        return this._advanceLevel();
      };

      LevelSequenceActor.prototype._advanceLevel = function() {
        var _this = this;
        this._cleanUpLevel();
        this._zoomIn(this.nextLevelActor, this.scene.time, function() {
          return _this._doneZooming();
        });
        this.activeLevelActor = this.nextLevelActor;
        return this;
      };

      LevelSequenceActor.prototype._cleanAll = function() {
        if (this.nextLevelActor != null) {
          this.nextLevelActor.discard();
          this.removeChild(this.nextLevelActor);
        }
        return this._cleanUpLevel();
      };

      LevelSequenceActor.prototype._cleanUpLevel = function() {
        if (this.activeLevelActor != null) {
          this.activeLevelActor.discard();
          return this.removeChild(this.activeLevelActor);
        }
      };

      LevelSequenceActor.prototype._doneZooming = function() {
        this._prepareNextLevel(this.levelSequence.nextLevel(), this.levelSequence.currentLevel().exit);
        return this.levelSequence.state.set(FNT.LevelSequenceStates.READY);
      };

      LevelSequenceActor.prototype._prepareNextLevel = function(level, position) {
        this.nextLevelActor = new FNT.LevelActor();
        this.nextLevelActor.prepare(level, position);
        return this.addChild(this.nextLevelActor);
      };

      LevelSequenceActor.prototype._prepareZoom = function() {
        var interpolator;
        interpolator = new CAAT.Interpolator().createExponentialInInterpolator(4, false);
        this.zoomScaleBehavior = new CAAT.ScaleBehavior();
        this.zoomScaleBehavior.anchor = CAAT.Actor.prototype.ANCHOR_CENTER;
        this.zoomScaleBehavior.startScaleX = this.zoomScaleBehavior.startScaleY = FNT.LevelActor.PORTAL_SCALE;
        this.zoomScaleBehavior.endScaleX = this.zoomScaleBehavior.endScaleY = 1;
        this.zoomScaleBehavior.setInterpolator(interpolator);
        this.zoomPath = new CAAT.LinearPath().setFinalPosition(0, 0);
        return this.zoomPathBehavior = new CAAT.PathBehavior().setPath(this.zoomPath).setInterpolator(new CAAT.Interpolator().createExponentialInInterpolator(4, false));
      };

      LevelSequenceActor.prototype._zoomIn = function(levelActor, startTime, callback) {
        var _this = this;
        levelActor.removeBorder();
        this.zoomScaleBehavior.emptyListenerList();
        if (callback != null) {
          this.zoomScaleBehavior.addListener({
            behaviorExpired: function(behavior, time, actor) {
              return callback();
            }
          });
        }
        this.zoomPath.setInitialPosition(levelActor.x, levelActor.y);
        this.zoomScaleBehavior.setFrameTime(startTime, FNT.Time.TWO_SECONDS);
        this.zoomPathBehavior.setFrameTime(startTime, FNT.Time.TWO_SECONDS);
        levelActor.addBehavior(this.zoomScaleBehavior);
        return levelActor.addBehavior(this.zoomPathBehavior);
      };

      return LevelSequenceActor;

    })(CAAT.ActorContainer);
  });

  namespace("FNT", function(exports) {
    exports.GameUIFactory = (function() {

      function GameUIFactory() {}

      return GameUIFactory;

    })();
    return exports.BackgroundContainer = (function(_super) {

      __extends(BackgroundContainer, _super);

      function BackgroundContainer() {
        BackgroundContainer.__super__.constructor.call(this);
        this;

      }

      BackgroundContainer.prototype.create = function(scene, width, height) {
        this.setBounds(0, 0, width, height);
        this.setFillStyle("#555");
        scene.addChild(this);
        return this;
      };

      return BackgroundContainer;

    })(CAAT.ActorContainer);
  });

  /*
   # Game Scene Actor:
   #  Main entry point for all the Actors that constitute the scene.
   #  Responsible for creating the scene with the Director.
  */


  namespace("FNT", function(exports) {
    exports.GameSceneActorFactory = (function() {

      function GameSceneActorFactory() {}

      GameSceneActorFactory.build = function(director, gameModel, gameController) {
        var gameActor;
        gameActor = new FNT.GameSceneActor().create(director, gameModel, gameController);
        return gameActor;
      };

      return GameSceneActorFactory;

    })();
    return exports.GameSceneActor = (function() {

      function GameSceneActor() {
        this;

      }

      /*
           # Creates the main game Scene.
           # @param director a CAAT.Director instance.
           # @param gameModel The FNT.GameModel instance that this Actor will represent.
      */


      GameSceneActor.prototype.create = function(director, gameModel, gameController) {
        var _this = this;
        this.director = director;
        this.gameModel = gameModel;
        this.gameController = gameController;
        this.directorScene = director.createScene();
        this.directorScene.onRenderStart = function(deltaTime) {
          return _this.gameController.step();
        };
        this.backgroundContainer = new FNT.BackgroundContainer().create(this.directorScene, director.width, director.height);
        this.createLevelContainer(this.gameModel.levelSequence);
        this.createPlayer(this.gameModel.player);
        this.gameUI = FNT.GameUIFactory.build(this.directorScene, this.gameModel);
        return this;
      };

      GameSceneActor.prototype.createLevelContainer = function(levelSequence) {
        return this.levelSequenceActor = new FNT.LevelSequenceActor().create(this.directorScene, levelSequence).setLocation(0, 0);
      };

      GameSceneActor.prototype.createPlayer = function(player) {
        return this.playerActor = new FNT.PlayerActor().create(this.directorScene, player);
      };

      return GameSceneActor;

    })();
  });

  namespace("FNT", function(exports) {
    exports.TextFactory = (function() {

      function TextFactory() {}

      TextFactory.build = function(parent, text, size) {
        return new FNT.Text().create(parent, text, size);
      };

      return TextFactory;

    })();
    return exports.Text = (function(_super) {

      __extends(Text, _super);

      function Text() {
        return Text.__super__.constructor.apply(this, arguments);
      }

      Text.prototype.create = function(parent, text, size) {
        this.setFont("" + size + "px " + FNT.Game.FONT);
        this.setText(text);
        this.setTextFillStyle(FNT.Color.FONT);
        this.cacheAsBitmap();
        parent.addChild(this);
        return this;
      };

      return Text;

    })(CAAT.TextActor);
  });

  namespace("FNT", function(exports) {
    exports.ButtonFactory = (function() {

      function ButtonFactory() {}

      ButtonFactory.build = function(parent) {
        return new FNT.Button().create(parent);
      };

      return ButtonFactory;

    })();
    return exports.Button = (function(_super) {

      __extends(Button, _super);

      function Button() {
        Button.__super__.constructor.call(this);
        this;

      }

      Button.prototype.create = function(parent) {
        this.setLineWidth(2);
        this.setStrokeStyle('#0');
        this.setFillStyle(FNT.Color.BUTTON);
        parent.addChild(this);
        return this;
      };

      Button.prototype.setText = function(text) {
        this.textActor = FNT.TextFactory.build(this, text, 14);
        this.textActor.setLocation((this.width - this.textActor.textWidth) / 2, this.height + 1);
        return this;
      };

      Button.prototype.setOnClick = function(onClick) {
        this.onClick = onClick;
        return this;
      };

      Button.prototype.mouseEnter = function(mouseEvent) {
        return this.setFillStyle(FNT.Color.BUTTON_DOWN);
      };

      Button.prototype.mouseExit = function(mouseEvent) {
        return this.setFillStyle(FNT.Color.BUTTON);
      };

      Button.prototype.mouseDown = function(mouseEvent) {
        return typeof this.onClick === "function" ? this.onClick(mouseEvent) : void 0;
      };

      return Button;

    })(FNT.CircleActor);
  });

  namespace("FNT", function(exports) {
    exports.PanelState = {
      SHY: "PANEL_STATE_SHY",
      OUTGOING: "PANEL_STATE_OUTGOING"
    };
    return exports.Panel = (function(_super) {

      __extends(Panel, _super);

      function Panel() {
        Panel.__super__.constructor.call(this);
        this;

      }

      Panel.prototype._getPositionForState = function(state) {
        throw "Should overide!";
      };

      Panel.prototype._getInitialPosition = function() {
        throw "Should overide!";
      };

      Panel.prototype._createText = function() {
        return console.log("No text added to Panel");
      };

      Panel.prototype.create = function(scene) {
        this.scene = scene;
        this.setFillStyle(FNT.Color.BACKGROUND);
        this.setLineWidth(2);
        this.setStrokeStyle(FNT.Color.BLACK);
        this.scene.addChild(this);
        this._createText();
        this._prepareBehaviors();
        return this;
      };

      Panel.prototype._prepareBehaviors = function() {
        this.path = new CAAT.LinearPath();
        this.pathBehavior = new CAAT.PathBehavior().setPath(this.path).setInterpolator(new CAAT.Interpolator().createExponentialOutInterpolator(6, false));
        return this.addBehavior(this.pathBehavior);
      };

      Panel.prototype.setState = function(state, animationTime) {
        var pos;
        if (animationTime == null) {
          animationTime = FNT.Time.ONE_SECOND;
        }
        pos = this._getPositionForState(state);
        this.path.setInitialPosition(this.x, this.y);
        this.path.setFinalPosition(pos.x, pos.y);
        return this.pathBehavior.setFrameTime(this.scene.time, animationTime);
      };

      Panel.prototype.animateIn = function() {
        this.setPosition(this._getInitialPosition());
        return this.setState(FNT.PanelState.OUTGOING, FNT.Time.FOUR_SECONDS);
      };

      return Panel;

    })(FNT.CircleActor);
  });

  namespace("FNT", function(exports) {
    exports.InfoPanelFactory = (function() {

      function InfoPanelFactory() {}

      InfoPanelFactory.build = function(scene) {
        return new FNT.InfoPanel().create(scene);
      };

      return InfoPanelFactory;

    })();
    return exports.InfoPanel = (function(_super) {

      __extends(InfoPanel, _super);

      function InfoPanel() {
        this.infoState = {};
        this.infoState[FNT.PanelState.SHY] = new CAAT.Point(FNT.Game.WIDTH, FNT.Game.HEIGHT);
        this.infoState[FNT.PanelState.OUTGOING] = new CAAT.Point(FNT.Game.WIDTH - 350, FNT.Game.HEIGHT - 320);
        InfoPanel.__super__.constructor.call(this);
        this;

      }

      InfoPanel.prototype.create = function(scene) {
        this.scene = scene;
        InfoPanel.__super__.create.call(this, this.scene);
        this.setDiameter(280);
        return this;
      };

      InfoPanel.prototype._getPositionForState = function(state) {
        return this.infoState[state];
      };

      InfoPanel.prototype._getInitialPosition = function() {
        return new CAAT.Point(FNT.Game.WIDTH + 500, FNT.Game.HEIGHT + 500);
      };

      InfoPanel.prototype._createText = function() {
        var gap, left, top;
        left = 65;
        top = 70;
        gap = 10;
        this.controls = FNT.TextFactory.build(this, FNT.Strings.CONTROLS, 24).setLocation(left, top);
        left += gap;
        top += this.controls.textHeight + gap;
        this.leftAndRight = FNT.TextFactory.build(this, FNT.Strings.LEFT_AND_RIGHT, 18).setLocation(left, top);
        top += this.leftAndRight.textHeight + gap;
        this.clamp = FNT.TextFactory.build(this, FNT.Strings.CLAMP, 16).setLocation(left, top);
        top += this.clamp.textHeight + gap;
        return this.retry = FNT.TextFactory.build(this, FNT.Strings.RETRY, 16).setLocation(left, top);
      };

      return InfoPanel;

    })(FNT.Panel);
  });

  namespace("FNT", function(exports) {
    exports.MenuPanelFactory = (function() {

      function MenuPanelFactory() {}

      MenuPanelFactory.build = function(scene) {
        return new FNT.MenuPanel().create(scene);
      };

      return MenuPanelFactory;

    })();
    return exports.MenuPanel = (function(_super) {

      __extends(MenuPanel, _super);

      function MenuPanel() {
        this.menuState = {};
        this.menuState[FNT.PanelState.SHY] = new CAAT.Point(-470, -450);
        this.menuState[FNT.PanelState.OUTGOING] = new CAAT.Point(-80, -80);
        MenuPanel.__super__.constructor.call(this);
        this;

      }

      MenuPanel.prototype.create = function(scene) {
        this.scene = scene;
        MenuPanel.__super__.create.call(this, this.scene);
        this.setDiameter(600);
        this.newGameButton = FNT.ButtonFactory.build(this).setDiameter(80).setText(FNT.Strings.NEW_GAME).setPosition(new CAAT.Point(500, 270));
        this.aboutButton = FNT.ButtonFactory.build(this).setDiameter(30).setText(FNT.Strings.ABOUT).setPosition(new CAAT.Point(300, 480));
        return this;
      };

      MenuPanel.prototype._getPositionForState = function(state) {
        return this.menuState[state];
      };

      MenuPanel.prototype._getInitialPosition = function() {
        return new CAAT.Point(-500, -500);
      };

      MenuPanel.prototype._createText = function() {
        this.textActor = FNT.TextFactory.build(this, FNT.Strings.GAME_NAME, 52);
        this.textActor.setLocation(100, 100);
        this.toggle = FNT.TextFactory.build(this, FNT.Strings.CLICK_TO_TOGGLE, 12);
        return this.toggle.setLocation(482, 482).setRotation(-Math.PI / 3.8);
      };

      return MenuPanel;

    })(FNT.Panel);
  });

  namespace("FNT", function(exports) {
    exports.MenuActorFactory = (function() {

      function MenuActorFactory() {}

      MenuActorFactory.build = function(scene, gameModel, menuPanel, infoPanel) {
        return new FNT.MenuActor().create(scene, gameModel, menuPanel, infoPanel);
      };

      return MenuActorFactory;

    })();
    return exports.MenuActor = (function() {

      function MenuActor() {}

      MenuActor.prototype.create = function(scene, gameModel, menuPanel, infoPanel) {
        var _this = this;
        this.scene = scene;
        this.gameModel = gameModel;
        this.menuPanel = menuPanel;
        this.infoPanel = infoPanel;
        this.menuPanel.newGameButton.setOnClick(function() {
          return _this._newGameClicked();
        });
        this.menuPanel.aboutButton.setOnClick(function() {
          return alert("HELP CLICKED!");
        });
        this.menuPanel.mouseDown = function(mouseEvent) {
          return _this._mouseDown(mouseEvent);
        };
        this.infoPanel.mouseDown = function(mouseEvent) {
          return _this._mouseDown(mouseEvent);
        };
        this.scene.enableInputList(1);
        this.scene.addActorToInputList(this.menuPanel, 0, 0);
        this.scene.addActorToInputList(this.infoPanel, 0, 0);
        this.scene.addActorToInputList(this.menuPanel.newGameButton, 0, 0);
        this.scene.addActorToInputList(this.menuPanel.aboutButton, 0, 0);
        this.menuPanel.animateIn();
        this.infoPanel.animateIn();
        this.state = FNT.PanelState.OUTGOING;
        return this;
      };

      MenuActor.prototype._mouseDown = function(mouseEvent) {
        return this._swapState();
      };

      MenuActor.prototype._swapState = function() {
        this.state = this.state === FNT.PanelState.SHY ? FNT.PanelState.OUTGOING : FNT.PanelState.SHY;
        this.menuPanel.setState(this.state);
        return this.infoPanel.setState(this.state);
      };

      MenuActor.prototype._newGameClicked = function() {
        this.state = FNT.PanelState.SHY;
        this.menuPanel.setState(this.state);
        this.infoPanel.setState(this.state);
        return this.gameModel.startGame();
      };

      return MenuActor;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.GameController = (function() {

      function GameController(gameModel, physicsController, keyboard) {
        this.gameModel = gameModel;
        this.physicsController = physicsController;
        this.keyboard = keyboard;
        this.registerKeyListeners(this.keyboard);
        this;

      }

      GameController.prototype.step = function() {
        if (this.physicsController != null) {
          return this.physicsController.step();
        }
      };

      GameController.prototype.reset = function() {
        return this.gameModel.startLevel();
      };

      GameController.prototype.registerKeyListeners = function() {
        var _this = this;
        this.keyboard.RESET.addListener(FNT.KeyDown, function() {
          return _this.reset();
        });
        return this.keyboard.NEXT_LEVEL.addListener(FNT.KeyDown, function() {
          return _this.gameModel.nextLevel();
        });
      };

      return GameController;

    })();
  });

  /* Encapsulates the state of Keyboard input
  */


  namespace("FNT", function(exports) {
    exports.KeyUp = "FNT_KEY_UP_EVENT";
    exports.KeyDown = "FNT_KEY_DOWN_EVENT";
    exports.Key = (function() {

      function Key() {
        this.state = FNT.KeyUp;
        this.keyDownListeners = [];
        this.keyUpListeners = [];
        this;

      }

      Key.prototype.addListener = function(keyEvent, callback) {
        switch (keyEvent) {
          case FNT.KeyUp:
            return this.keyUpListeners.push(callback);
          case FNT.KeyDown:
            return this.keyDownListeners.push(callback);
          default:
            return alert("WEIRD STUFF HAPPENING!");
        }
      };

      Key.prototype.notifyListeners = function() {
        var callback, listeners, _i, _len, _results;
        listeners = this.state === FNT.KeyDown ? this.keyDownListeners : this.keyUpListeners;
        _results = [];
        for (_i = 0, _len = listeners.length; _i < _len; _i++) {
          callback = listeners[_i];
          _results.push(callback());
        }
        return _results;
      };

      return Key;

    })();
    return exports.Keyboard = (function() {

      function Keyboard() {
        this._keyMap = {};
        this._keyMap[CAAT.Keys.j] = this.ORBIT;
        this._keyMap[CAAT.Keys.r] = this.RESET;
        this._keyMap[CAAT.Keys.n] = this.NEXT_LEVEL;
        this;

      }

      Keyboard.prototype.ORBIT = new FNT.Key();

      Keyboard.prototype.RESET = new FNT.Key();

      Keyboard.prototype.NEXT_LEVEL = new FNT.Key();

      Keyboard.prototype.UP = false;

      Keyboard.prototype.DOWN = false;

      Keyboard.prototype.LEFT = false;

      Keyboard.prototype.RIGHT = false;

      Keyboard.prototype.create = function() {
        /*
               # Register a CAAT key listener function
        */

        var _this = this;
        CAAT.registerKeyListener(function(keyEvent) {
          return _this.checkInput(keyEvent);
        });
        return this;
      };

      Keyboard.prototype.addListener = function(key, keyEvent, callback) {
        if (!(this.listeners[key] != null)) {
          this.listeners[key] = {};
          this.listeners[key][FNT.KeyUp] = [];
          this.listeners[key][FNT.KeyDown] = [];
        }
        return this.listeners[key][keyEvent].push(callback);
      };

      Keyboard.prototype.notifyListeners = function(key, keyEvent) {
        var callback, _i, _len, _ref, _results;
        _ref = this.listeners[key][keyEvent];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback());
        }
        return _results;
      };

      Keyboard.prototype.getKeyState = function(keyEvent) {
        keyEvent.preventDefault();
        if (keyEvent.getAction() === 'down') {
          return FNT.KeyDown;
        } else {
          return FNT.KeyUp;
        }
      };

      Keyboard.prototype._handleKeyEvent = function(keyEvent) {
        var key, newState;
        key = this._keyMap[keyEvent.getKeyCode()];
        newState = this.getKeyState(keyEvent);
        if (newState !== key.state) {
          key.state = newState;
          return key.notifyListeners();
        }
      };

      Keyboard.prototype.checkInput = function(keyEvent) {
        switch (keyEvent.getKeyCode()) {
          case CAAT.Keys.UP:
          case CAAT.Keys.w:
            this.UP = this.getKeyState(keyEvent) === FNT.KeyDown;
            break;
          case CAAT.Keys.DOWN:
          case CAAT.Keys.s:
            this.DOWN = this.getKeyState(keyEvent) === FNT.KeyDown;
            break;
          case CAAT.Keys.LEFT:
          case CAAT.Keys.a:
            this.LEFT = this.getKeyState(keyEvent) === FNT.KeyDown;
            break;
          case CAAT.Keys.RIGHT:
          case CAAT.Keys.d:
            this.RIGHT = this.getKeyState(keyEvent) === FNT.KeyDown;
        }
        if (keyEvent.getKeyCode() in this._keyMap) {
          return this._handleKeyEvent(keyEvent);
        }
      };

      return Keyboard;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.PhysicsConstants = {
      GRAVITY: new Vector(0, 200.0),
      MOVE_SPEED: 200,
      JUMP_SPEED: -200,
      AIR_MOVE_SPEED: 60,
      ORBIT_SPEED: 200,
      ORBIT_ATTACH_THRESHOLD: 4,
      INITIAL_ORBIT_OFFSET: FNT.PlayerConstants.RADIUS / 2,
      MINIMUM_INNER_ORBIT_OFFSET: FNT.PlayerConstants.RADIUS / 2,
      MINIMUM_OUTER_ORBIT_OFFSET: FNT.PlayerConstants.RADIUS / 2,
      ORBIT_CHANGE_PER_SECOND: FNT.PlayerConstants.RADIUS / 2
    };
  });

  /* CouplePosition Behaviour couples the position of an arbitrary entity to a particle
  */


  namespace("FNT", function(exports) {
    return exports.CouplePosition = (function(_super) {

      __extends(CouplePosition, _super);

      function CouplePosition(target) {
        this.target = target;
        CouplePosition.__super__.constructor.apply(this, arguments);
      }

      CouplePosition.prototype.apply = function(p, dt, index) {
        return this.target.setPosition(p.pos);
      };

      return CouplePosition;

    })(Behaviour);
  });

  /* This Behaviour handles Collisions with the FNT.LevelModel
  */


  namespace("FNT", function(exports) {
    return exports.LevelCollision = (function(_super) {

      __extends(LevelCollision, _super);

      function LevelCollision(levelSequence, keyboard, useMass, callback) {
        this.levelSequence = levelSequence;
        this.keyboard = keyboard;
        this.useMass = useMass != null ? useMass : true;
        this.callback = callback != null ? callback : null;
        this._delta = new Vector();
        LevelCollision.__super__.constructor.apply(this, arguments);
      }

      LevelCollision.prototype.setActive = function(isActive) {
        this.isActive = isActive;
      };

      LevelCollision.prototype.apply = function(p, dt, index) {
        if (!this.isActive) {
          return;
        }
        this.handleCollisions(p);
        return this.applyUserInput(p);
      };

      LevelCollision.prototype.handleCollisions = function(p) {
        var delta, dist, inner_perimeter, outer_perimeter, outward_force, overlap, ring, _i, _len, _ref, _results;
        this.onRing = false;
        _ref = this.levelSequence.currentLevel().getRings();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ring = _ref[_i];
          this._delta.copy(p.pos).sub(ring.position);
          dist = this._delta.mag();
          outer_perimeter = ring.radius + p.radius;
          inner_perimeter = ring.radius - p.radius;
          if ((inner_perimeter < dist && dist < outer_perimeter)) {
            if (dist > ring.radius) {
              if (p.pos.y < ring.position.y) {
                this.onRing = true;
              }
              overlap = outer_perimeter - dist;
              delta = this._delta.clone();
              outward_force = delta.dot(p.vel) / delta.magSq();
              if (outward_force >= 0) {
                p.pos.add(p.vel.clone().norm().scale(overlap / 10));
              } else {
                p.pos.add(this._delta.norm().scale(overlap));
              }
            } else {
              if (p.pos.y > ring.position.y) {
                this.onRing = true;
              }
              overlap = inner_perimeter - dist;
              p.pos.add(this._delta.norm().scale(overlap));
            }
            _results.push(typeof this.callback === "function" ? this.callback(p, o, overlap) : void 0);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      LevelCollision.prototype.applyUserInput = function(p) {
        var speed;
        speed = FNT.PhysicsConstants.AIR_MOVE_SPEED;
        if (this.onRing) {
          speed = FNT.PhysicsConstants.MOVE_SPEED;
          if (this.keyboard.JUMP) {
            p.acc.add(new Vector(0, FNT.PhysicsConstants.JUMP_SPEED));
          }
        }
        if (this.keyboard.LEFT) {
          p.acc.add(new Vector(-1 * speed, 0));
        }
        if (this.keyboard.RIGHT) {
          return p.acc.add(new Vector(speed, 0));
        }
      };

      return LevelCollision;

    })(Behaviour);
  });

  /* This behaviour attaches the particle to the first Ring it encounters and 'glides' it around the Ring
  */


  namespace("FNT", function(exports) {
    return exports.Orbiter = (function(_super) {

      __extends(Orbiter, _super);

      function Orbiter(levelSequence, keyboard, callback) {
        this.levelSequence = levelSequence;
        this.keyboard = keyboard;
        this.callback = callback != null ? callback : null;
        this._delta = new Vector();
        this._acceleration = new Vector();
        this._accumulated_acceleration = new Vector();
        this.orbit = 0;
        this.TRACKING_FACTOR = 1.0;
        Orbiter.__super__.constructor.apply(this, arguments);
        this;

      }

      Orbiter.prototype.setActive = function(isActive) {
        this.isActive = isActive;
        return this.ring = null;
      };

      Orbiter.prototype.applyUserInput = function(p, dt) {
        var speed;
        this._acceleration.clear();
        speed = FNT.PhysicsConstants.ORBIT_SPEED;
        if (this.keyboard.RIGHT) {
          this._acceleration.x += speed;
        }
        if (this.keyboard.LEFT) {
          this._acceleration.x -= speed;
        }
        this._accumulated_acceleration.add(this._acceleration);
        this.adjustOrbitOverTime(p, dt);
        return p.acc.add(this._acceleration);
      };

      Orbiter.prototype.adjustOrbitOverTime = function(p, dt) {
        if (this.orbit > this.ring.radius) {
          if (this.orbit > (this.ring.radius + FNT.PhysicsConstants.MINIMUM_OUTER_ORBIT_OFFSET)) {
            return this.orbit -= dt * FNT.PhysicsConstants.ORBIT_CHANGE_PER_SECOND;
          }
        } else {
          if (this.orbit < (this.ring.radius - FNT.PhysicsConstants.MINIMUM_INNER_ORBIT_OFFSET)) {
            return this.orbit += dt * FNT.PhysicsConstants.ORBIT_CHANGE_PER_SECOND;
          }
        }
      };

      Orbiter.prototype.applyTracking = function(p) {
        var dist, force;
        dist = this.distanceBetween(p, this.ring) + 0.000001;
        force = (this.orbit - dist) * this.TRACKING_FACTOR;
        return p.pos.add(this._delta.norm().scale(force));
      };

      Orbiter.prototype.apply = function(p, dt, index) {
        var _ref;
        if (!this.isActive) {
          return;
        }
        if ((_ref = this.ring) == null) {
          this.ring = this.findAttachableRing(p);
        }
        if (!(this.ring != null)) {
          return;
        }
        this.applyTracking(p);
        return this.applyUserInput(p, dt);
      };

      Orbiter.prototype.findAttachableRing = function(p) {
        var dist, inner_perimeter, outer_perimeter, r, threshold, _i, _len, _ref;
        _ref = this.levelSequence.currentLevel().getRings();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          r = _ref[_i];
          dist = this.distanceBetween(p, r);
          outer_perimeter = r.radius + p.radius;
          inner_perimeter = r.radius - p.radius;
          threshold = FNT.PhysicsConstants.ORBIT_ATTACH_THRESHOLD;
          if ((inner_perimeter - threshold < dist && dist < outer_perimeter + threshold)) {
            this.ring = r;
            this._accumulated_acceleration.clear();
            if (dist < this.ring.radius) {
              this.orbit = this.ring.radius - FNT.PhysicsConstants.INITIAL_ORBIT_OFFSET;
            } else {
              this.orbit = this.ring.radius + FNT.PhysicsConstants.INITIAL_ORBIT_OFFSET;
            }
            if (typeof this.callback === "function") {
              this.callback(p, this.ring);
            }
            return this.ring;
          }
        }
        return null;
      };

      Orbiter.prototype.distanceBetween = function(a, b) {
        this._delta.copy(a.pos).sub(b.position);
        return this._delta.mag();
      };

      return Orbiter;

    })(Behaviour);
  });

  /* This behaviour calls a callback when particles enter a specific circle
  */


  namespace("FNT", function(exports) {
    return exports.Portal = (function(_super) {

      __extends(Portal, _super);

      function Portal(levelSequence, player, radius, callback) {
        this.levelSequence = levelSequence;
        this.player = player;
        this.radius = radius;
        this.callback = callback;
        Portal.__super__.constructor.call(this);
        this._delta = new Vector();
        this;

      }

      Portal.prototype.apply = function(p, dt, index) {
        var dist, position;
        if (this.player.state.get() === FNT.PlayerStates.DEAD) {
          return;
        }
        position = this._getPortalPosition();
        dist = this._delta.copy(position).sub(p.pos).mag();
        if (dist < this.radius) {
          return this.callback();
        }
      };

      Portal.prototype._getPortalPosition = function() {
        return new Vector(this.levelSequence.currentLevel().exit.x, this.levelSequence.currentLevel().exit.y);
      };

      return Portal;

    })(Behaviour);
  });

  /* This class models a Player's interaction with the physics system
  */


  namespace("FNT", function(exports) {
    return exports.PlayerParticle = (function(_super) {

      __extends(PlayerParticle, _super);

      function PlayerParticle() {
        PlayerParticle.__super__.constructor.call(this);
        this;

      }

      PlayerParticle.prototype.create = function(playerModel, levelSequence, keyboard) {
        var _this = this;
        this.playerModel = playerModel;
        this.levelSequence = levelSequence;
        this.keyboard = keyboard;
        this.couplePosition = new FNT.CouplePosition(this.playerModel);
        this.keyboard.ORBIT.addListener(FNT.KeyDown, function() {
          return _this.setOrbitState(true);
        });
        this.keyboard.ORBIT.addListener(FNT.KeyUp, function() {
          return _this.setOrbitState(false);
        });
        this.setRadius(FNT.PlayerConstants.RADIUS);
        this.levelCollision = new FNT.LevelCollision(this.levelSequence, this.keyboard);
        this.orbiter = new FNT.Orbiter(this.levelSequence, this.keyboard, this.onOrbitStart);
        this.levelCollision.setActive(false);
        this.orbiter.setActive(false);
        this.behaviours.push(this.orbiter);
        this.behaviours.push(this.levelCollision);
        this.behaviours.push(this.couplePosition);
        this.playerModel.addObserver(this);
        return this;
      };

      PlayerParticle.prototype.setOrbitState = function(isOrbiting) {
        this.clearState();
        this.orbiter.setActive(isOrbiting);
        return this.levelCollision.setActive(!isOrbiting);
      };

      PlayerParticle.prototype.clearState = function() {
        this.playerModel.state.set(FNT.PlayerStates.NORMAL);
        return this.levelSequence.currentLevel().resetAllRings();
      };

      PlayerParticle.prototype.handleEvent = function(event) {
        switch (event.type) {
          case FNT.PlayerEvents.SPAWN:
            return this.spawn();
          case FNT.PlayerStates.DEAD:
            return this.fixed = true;
        }
      };

      PlayerParticle.prototype.onOrbitStart = function(p, ring) {
        p.playerModel.state.set(FNT.PlayerStates.ORBITING);
        return ring.setOrbited(true);
      };

      PlayerParticle.prototype.spawn = function() {
        this.fixed = false;
        this.moveTo(new Vector(this.playerModel.position.x, this.playerModel.position.y));
        this.orbiter.setActive(false);
        return this.levelCollision.setActive(true);
      };

      return PlayerParticle;

    })(Particle);
  });

  /* Controller responsible for physics
  */


  namespace("FNT", function(exports) {
    return exports.PhysicsController = (function() {

      function PhysicsController() {}

      PhysicsController.prototype.create = function(gameModel, keyboard) {
        var _this = this;
        this.gameModel = gameModel;
        this.keyboard = keyboard;
        this.physics = new Physics(new Verlet());
        this.gravity = new ConstantForce(FNT.PhysicsConstants.GRAVITY);
        this.physics.behaviours.push(this.gravity);
        this.initPlayerPhysics(this.gameModel.player, this.gameModel.levelSequence);
        this.portal = new FNT.Portal(this.gameModel.levelSequence, this.gameModel.player, 50, function() {
          return _this.onPortalCollision();
        });
        this.physics.behaviours.push(this.portal);
        this.gameModel.addObserver(this);
        return this;
      };

      PhysicsController.prototype.step = function() {
        return this.physics.step();
      };

      PhysicsController.prototype.initPlayerPhysics = function(playerModel, levelSequence) {
        this.player = new FNT.PlayerParticle().create(playerModel, levelSequence, this.keyboard);
        return this.physics.particles.push(this.player);
      };

      PhysicsController.prototype.onPortalCollision = function() {
        return this.gameModel.nextLevel();
      };

      return PhysicsController;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.GameFactory = (function() {

      function GameFactory() {}

      GameFactory.build = function(director) {
        var gameController, gameModel;
        gameModel = this.createGameModel();
        gameController = this.createGameController(gameModel);
        return this.createGameView(director, gameModel, gameController);
      };

      GameFactory.createGameModel = function() {
        var levelSequence, playerModel;
        levelSequence = FNT.LevelSequenceFactory.build(FNT.GameModes.quest.levelData);
        playerModel = FNT.PlayerFactory.build();
        return new FNT.GameModel(levelSequence, playerModel);
      };

      GameFactory.createGameController = function(gameModel) {
        var keyboard, physics;
        keyboard = new FNT.Keyboard().create();
        physics = new FNT.PhysicsController().create(gameModel, keyboard);
        return new FNT.GameController(gameModel, physics, keyboard);
      };

      GameFactory.createGameView = function(director, gameModel, gameController) {
        var gameScene;
        return gameScene = FNT.GameSceneActorFactory.build(director, gameModel, gameController);
      };

      return GameFactory;

    })();
  });

  namespace("FNT", function(exports) {
    return exports.GameUIFactory = (function() {

      function GameUIFactory() {}

      GameUIFactory.build = function(scene, gameModel) {
        var infoPanel, menuPanel;
        menuPanel = FNT.MenuPanelFactory.build(scene);
        infoPanel = FNT.InfoPanelFactory.build(scene);
        return FNT.MenuActorFactory.build(scene, gameModel, menuPanel, infoPanel);
      };

      return GameUIFactory;

    })();
  });

  /*
   # Main Entry Point
  */


  namespace("FNT", function(exports) {
    var __FNT__createLoadingScene, __createCanvas, __end_loading;
    __FNT__createLoadingScene = function(director) {
      var ladingActor, ladingImg, oActor, oImg, scene;
      ladingImg = director.getImage('lading');
      oImg = director.getImage('rueda');
      scene = director.createScene();
      scene.addChild(new CAAT.Actor().setBackgroundImage(director.getImage('splash')));
      scene.addChild(ladingActor = new CAAT.Actor().setBackgroundImage(ladingImg).setLocation(director.width - ladingImg.width - 10, director.height - ladingImg.height - 30));
      scene.addChild(oActor = new CAAT.Actor().setBackgroundImage(oImg).setLocation(ladingActor.x + 20, ladingActor.y + 10).addBehavior(new CAAT.RotateBehavior().setValues(0, 2 * Math.PI).setFrameTime(0, FNT.Time.ONE_SECOND).setCycle(true)));
      scene.loadedImage = function(count, images) {
        if (count === images.length) {
          return __end_loading(director, images);
        }
      };
      return scene;
    };
    __end_loading = function(director, images) {
      var gameScene;
      director.emptyScenes();
      director.setImagesCache(images);
      gameScene = FNT.GameFactory.build(director);
      return director.easeIn(0, CAAT.Scene.prototype.EASE_TRANSLATE, 1000, false, CAAT.Actor.prototype.ANCHOR_TOP, new CAAT.Interpolator().createExponentialInOutInterpolator(5, false));
    };
    __createCanvas = function() {
      return new CAAT.Director().initialize(FNT.Game.WIDTH, FNT.Game.HEIGHT).setClear(false);
    };
    return exports.initGame = function(font) {
      var director, prefix;
      console.log("Starting game");
      FNT.Game.FONT = font;
      CAAT.DEBUG = 1;
      director = __createCanvas();
      prefix = typeof __RESOURCE_URL !== "undefined" && __RESOURCE_URL !== null ? __RESOURCE_URL : '';
      new CAAT.ImagePreloader().loadImages([
        {
          id: 'splash',
          url: prefix + 'splash/splash.jpg'
        }, {
          id: 'lading',
          url: prefix + 'splash/lading.png'
        }, {
          id: 'rueda',
          url: prefix + 'splash/rueda.png'
        }
      ], function(counter, images) {
        var loading_scene;
        if (counter === images.length) {
          director.setImagesCache(images);
          loading_scene = __FNT__createLoadingScene(director);
          return new CAAT.ImagePreloader().loadImages([], function(counter, images) {
            if (counter === images.length) {
              director.addAudio("music", prefix + "res/sound/music.mp3");
            }
            return loading_scene.loadedImage(counter, images);
          });
        }
      });
      return CAAT.loop(60);
    };
  });

}).call(this);
